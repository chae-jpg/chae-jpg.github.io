---
date: '2025-09-15'
draft: false
title: 'BOJ 12789 - 도키도키 간식드리미'
tags: ['PS']
summary: 간단한 스택 문제
---

```cpp
// 도키도키 간식드리미 - 실버 3

#include <bits/stdc++.h>

using namespace std;

string solve(int n, vector<int>& v) {

    stack<int> small, large;
    small.push(0);
    large.push(n+1);
    for (int i = 0; i < n; i++) {
        int j = v[i];

        if (j == small.top() + 1) {
            small.push(j);

            while (!large.empty() && large.top() == small.top() + 1) {
                small.push(large.top());
                large.pop();
            }

        } else {
            if (large.top() < j) return "Sad";
            large.push(j);
        }
    }
    return "Nice";
}

int main() {
    int n;
    vector<int> v;
    cin >> n;
    v.assign(n, 0);

    for (int i = 0; i < n; i++) {
        cin >> v[i];
    }

    cout << solve(n, v);
}
```

급해서 간단히 쓰고 감; 

아이디어 자체는 간단함. 1, 2, 3 ... 처럼 오름차순으로 보내야 하는 곳이 있고, 그 곳에 값들을 보내기 위해 다른 공간에 값들을 차곡차곡 쌓으면 되는 것임.

근데 생각할 점은
1) 그 값을 쌓는 공간에는 LIFO가 적용됨 -> 스택 사용
2) 다른 공간에 값을 차곡차곡 쌓긴 할 건데, 스택이니까 쌓인 순서대로만 나가야 됨. 근데? 보내야 하는 곳은 오름차순을 요구함! -> 스택에도 **큰 수부터 차례대로** 쌓여야 함. 이게 포인트

나는 근데 이거 보고 스택이다 스택!! 하고 신나서 당장 스택 2개를 질러버림,,, 사실 스택 하나여도 풀 수 있죠? 나가는 공간은 어떤 값들이 어떻게 나갔는지를 보관해야 할 필요는 없기 때문에 그냥 인덱스로만 관리해도 무방함ㅎㅎ

아무튼 간단하고 재미있는 스택 문제였다... 지문이 좀 이상해서 질문 게시판을 참조해야 되기는 했지만 
> 어떤 개념을 쓰는 문제라고 해서 그 개념 쓸 생각에만 매몰되지 말자!

라는 좋은 경험을 얻었다...