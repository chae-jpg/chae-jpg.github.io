<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>핸즈온 머신러닝 - 2장 | CS Playground</title><meta name=keywords content="ML"><meta name=description content="데이터 분석 파이프라인을 알아봅시다."><meta name=author content="Me"><link rel=canonical href=http://localhost:1313/posts/handson_chap2/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/handson_chap2/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="http://localhost:1313/posts/handson_chap2/"><meta property="og:site_name" content="CS Playground"><meta property="og:title" content="핸즈온 머신러닝 - 2장"><meta property="og:description" content="데이터 분석 파이프라인을 알아봅시다."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-14T00:00:00+00:00"><meta property="article:modified_time" content="2025-07-14T00:00:00+00:00"><meta property="article:tag" content="ML"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="핸즈온 머신러닝 - 2장"><meta name=twitter:description content="데이터 분석 파이프라인을 알아봅시다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"핸즈온 머신러닝 - 2장","item":"http://localhost:1313/posts/handson_chap2/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"핸즈온 머신러닝 - 2장","name":"핸즈온 머신러닝 - 2장","description":"데이터 분석 파이프라인을 알아봅시다.","keywords":["ML"],"articleBody":" 2장에서는 캘리포니아 주택 가격 데이터셋을 활용해 머신러닝 프로젝트를 처음부터 끝까지 직접 진행해보면서 배우는 것을 목표로 한다.\n큰 그림 보기 문제 정의 풀고자 하는 문제가 무엇인지 먼저 정의하는 것이 필요함. 그렇게 하여 문제 상황을 정확히 파악하고, 해당 문제에 적합한 시스템을 설계하게 됨. 지금 문제는 레이블된 훈련 샘플이 있고, 여러 특성을 통해 한 개의 값을 예측하므로 지도 학습, 단변량 회귀 문제가 됨.\n성능 측정 지표 선택 회귀 문제에서는 일반적으로 평균 제곱근 오차, RMSE를 사용한다. $RMSE(X, h) = \\sqrt{\\frac{1}{m} \\sum_{i=1}^{n} (h(x^{(i)}) - y^{(i)})^2}$\n하지만, 이상치로 보이는 구역이 많은 경우, 평균 절대 오차, MAE를 사용하기도 한다. $MAE(X, h) = \\frac{1}{m}\\sum_{i=1}^{m}|h(x^{(i)})-y^{(i)}|$\n둘 모두 예측값의 벡터와 타깃값의 벡터 사이의 거리를 재는 방식이다. 거리 측정에는 여러 방식을 사용할 수 있다.\n유클리드 노름 : RMSE 계산과 같다. $l_2$ 노름이라고도 부른다. 맨해튼 노름 : 절댓값의 합을 계산한다. $l_1$ 노름이라고도 부른다. $l_k$ 노름 = $(|v_0|^k + |v_1|^k + … + |v_n|^k)^{\\frac{1}{k}}$ 가정 검사 시스템에서 요구로 출력을 하고 있는 출력이 현재 개발하고자 하는 모델의 출력과 일치한지 (ex: 가정에서는 수치형을 출력하고자 하는데 범주형을 요구한다던가) 확인해야한다.\n데이터 가져오기 데이터 다운로드 아래 코드를 실행하면 데이터를 다운로드 할 수 있다.\nfrom pathlib import Path import pandas as pd import tarfile import urllib.request def load_housing_data(): tarball_path = Path(\"datasets/housing.tgz\") if not tarball_path.is_file(): Path(\"datasets\").mkdir(parents=True, exist_ok=True) url = \"https://github.com/ageron/data/raw/main/housing.tgz\" urllib.request.urlretrieve(url, tarball_path) with tarfile.open(tarball_path) as housing_tarball: housing_tarball.extractall(path=\"datasets\") return pd.read_csv(\"datasets/housing/housing.csv\") housing = load_housing_data() tarball_path에 있는 파일이 있는지 확인한다. 1-1. 만약 파일이 없다면, datasets 폴더를 만들고 그 폴더에 tgz 파일을 다운로드받은 뒤, 압축 해제를 한다. 파일을 pandas DataFrame으로 읽어온 결과를 리턴한다. 데이터 구조 훑어보기 head() 메서드를 사용하면 데이터의 첫 다섯 행을 읽어올 수 있다. info() 메서드는 데이터에 관한 간략한 설명을 보여준다. 특히, 전체 행 수, 각 특성의 데이터 타입, 널이 아닌 값의 개수를 확인하는 데 유용하다. 다음과 같은 정보를 알 수 있다.\n전체 샘플 개수는 20640개이다. total_bedrooms는 20433개만 널값이 아니다. 즉, 나머지 207개는 이 특성을 가지고 있지 않다. ocean_proximity 필드를 제외한 모든 특성이 숫자형이다. value_counts() 메서드는 어떤 카테고리가 있고, 각 카테고리마다 얼마나 많은 구역이 있는지 확인할 수 있다. describe 메서드는 숫자형 특성의 요약 정보를 보여준다.\nhist() 메서드는 모든 숫자형 형태에 대한 히스토그램을 출력할 수 있다. 이를 통해 알 수 있는 사실은 다음과 같다.\n중간 소득이 US 달러로 표시되어 있지 않다. 따라서, 그 단위를 통일하는 것이 필요하다. 중간 주택 연도와 중간 주택 가격 그래프의 오른쪽 값이 심하게 높아지면서 그래프가 끝나는 것으로 보아 최댓값과 최솟값이 한정되어 있음을 알 수 있다. 특성들의 스케일이 많이 다르다. 많은 히스토그램에서 오른쪽 꼬리가 더 길다. 이러한 형태는 일부 머신러닝 알고리즘에서 패턴을 찾기 어렵게 만든다. 테스트 세트 만들기 데이터 스누핑 편향 : 테스트 세트로 일반화 오차를 추정하여 매우 낙관적인 추정이 나오게 되는 것 다음과 같은 코드로 랜덤으로 테스트 세트를 만들 수 있다.\nimport numpy as np def shuffle_and_split_data(data, test_ratio): shuffled_indices = np.random.permutation(len(data)) # 괄호 안 숫자 범위로 생성된 배열을 무작위로 섞음. test_set_size = int(len(data) * test_ratio) test_indices = shuffled_indices[:test_set_size] train_indices = shuffled_indices[test_set_size:] return data.iloc[train_indices], data.iloc[test_indices] 하지만, 프로그램을 실행할 때마다 다른 테스트 세트가 생성된다는 문제점이 존재한다. 이를 해결하기 위해서는,\n처음 실행에서 테스트 세트를 저장하고 다음번 실행에서 불러들이기 항상 같은 난수 인덱스가 생성되도록 np.random.permutation()을 호출하기 전에 난수 발생기의 초깃값을 지정하기 하지만 위 방법 또한 데이터셋이 업데이트된 경우 문제가 생긴다. 따라서, 샘플의 식별자를 사용하여 테스트 세트로 보낼지 말지를 결정할 수 있다.\nfrom zlib import crc32 def is_id_in_test_set(identifier, test_ratio): return crc32(np.int64(identifier).tobytes()) \u003c test_ratio * 2 ** 32 def split_data_with_id_hash(data, test_ratio, id_column): ids = data[id_column] in_test_set = ids.apply(lambda id_: is_id_in_test_set(id_, test_ratio)) return data.loc[~in_test_set], data.loc[in_test_set] 위 방법을 통해 나눈 훈련 / 테스트 세트를 보면 다음과 같다.\n사이킷런을 사용하면 위 과정을 간단히 구현할 수 있다. 가장 간단한 함수는 train_test_split으로, 난수 초깃값을 설정하는 기능과 행의 개수가 같은 여러 개의 데이터셋을 넘겨 동일한 인덱스를 기반으로 나누는 기능이 존재한다.\nfrom sklearn.model_selection import train_test_split train_set, test_set = train_test_split(housing, test_size=0.2, random_state=42) 앞서 본 샘플링은 순수한 랜덤 샘플링이다. 데이터셋이 충분히 크다면 괜찮지만, 그렇지 않다면 샘플링 편향이 생길 가능성이 크다. 이를 위해 계층적 샘플링이 존재한다.\n계층적 샘플링 : 전체를 계층이라는 동질의 그룹으로 나누고, 테스트 세트가 전체를 대표할 수 있도록 각 계층에서 올바른 수의 샘플을 추출하는 것. 이를 위해 전체를 여러 개의 계층으로 나눈 뒤, 계층의 비율대로 전체에서 샘플링하는 것이 가능하다.\nhousing[\"income_cat\"] = pd.cut(housing[\"median_income\"], bins=[0., 1.5, 3.0, 4.5, 6., np.inf], labels=[1, 2, 3, 4, 5]) pandas.cut reference pandas.cut 함수는 특정 1차원 배열을 bins에 따라 해당 개수, 또는 해당 구간에 따라 분할한 뒤, 각 값들에 대해 해당하는 구간의 labels의 값을 부여한다. 사이킷런의 sklearn.model_selection 패키지 안에는 여러 가지 분할기 클래스를 제공한다. 모든 분할기는 또한 훈련과 테스트 분할에 대한 반복자를 반환하는 split() 메소드를 가지고 있다.\n이 코드에서는 StratifiedShuffleSplit을 사용해 10개의 다른 계층 분할을 생성한다.\nfrom sklearn.model_selection import StratifiedShuffleSplit splitter = StratifiedShuffleSplit(n_splits=10, test_size=0.2, random_state=42) strat_splits = [] for train_index, test_index in splitter.split(housing, housing[\"income_cat\"]): strat_train_set_n = housing.iloc[train_index] strat_test_set_n = housing.iloc[test_index] strat_splits.append([strat_train_set_n, strat_test_set_n]) 첫 번째 분할을 다음과 같이 사용할 수 있다.\nstrat_train_set, strat_test_set = strat_splits[0] 다음과 같은 방식으로 계층적 샘플링을 코드 한 줄로 불러오는 것도 가능하다.\nstrat_train_set, strat_test_set = train_test_split(housing, test_size=0.2, stratify=housing[\"income_cat\"], random_state=42) 데이터 이해를 위한 탐색과 시각화 먼저, 다음과 같은 코드를 통해 지리 정보를 산점도로 만들어 시각화해보자.\nhousing.plot(kind=\"scatter\", x=\"longitude\", y=\"latitude\", grid=True) plt.xlabel(\"경도\") plt.ylabel(\"위도\") plt.show() 이 그래프에서, 데이터 포인트가 밀접된 영역을 확인해보자.\nhousing.plot(kind=\"scatter\", x=\"longitude\", y=\"latitude\", grid=True, alpha=0.2) plt.xlabel(\"logitude\") plt.ylabel(\"latitude\") plt.show() 다음으로는 구역의 인구와 주택가격까지 그림에 나타내보자.\nhousing.plot(kind=\"scatter\", x=\"longitude\", y=\"latitude\", grid=True, s=housing[\"population\"] / 100, label=\"population\", c=\"median_house_value\", cmap=\"jet\", colorbar=True, legend=True, figsize=(10, 7)) plt.show() 상관관계 조사하기 모든 특성 간의 표준 상관계수를 corr() 메서드를 사용해 쉽게 계산할 수 있다.\ncorr_matrix[\"median_house_value\"].sort_values(ascending=False) median_house_value 1.000000 median_income 0.688380 total_rooms 0.137455 housing_median_age 0.102175 households 0.071426 total_bedrooms 0.054635 population -0.020153 longitude -0.050859 latitude -0.139584 Name: median_house_value, dtype: float64 상관관계의 범위는 -1부터 1까지로, 1에 가까우면 강한 양의 상관관계, -1에 가까우면 강한 음의 상관관계를 가진다는 뜻이다.\n판다스의 scatter_matrix 함수를 통해 숫자형 특성 간 산점도를 그려보는 것 또한 가능하다.\nfrom pandas.plotting import scatter_matrix attributes = [\"median_house_value\", \"median_income\", \"total_rooms\", \"housing_median_age\"] scatter_matrix(housing[attributes], figsize=(12, 8)) plt.show() 이 그림을 보았을 때, 중간 주택 가격을 예측하는 데 중간 소득이 가장 유용해보인다는 것을 발견할 수 있다. 이 산점도를 확대해보자.\n이 그래프를 통해 알 수 있는 사실은 다음과 같다.\n상관관계가 매우 강하다. 위쪽으로 향하는 경향이 보인다. 포인트들이 너무 많이 퍼져 있지는 않다. 가격의 한계값이 수평선으로 잘 보이는데, 이러한 형태가 다른 곳에서도 더 나타나므로 이상한 형태를 알고리즘이 학습하지 않도록 구역을 제거할 수 있다. 특성 조합으로 실험하기 특정 구역의 가구 당 방 개수가 몇 개인지, 방 당 침실 개수가 몇 개인지 등 여러 특성을 조합하여 새로운 특성을 만들 수 있다.\nhousing[\"rooms_per_house\"] = housing[\"total_rooms\"] / housing[\"population\"] housing[\"bedrooms_ratio\"] = housing[\"total_bedrooms\"] / housing[\"total_rooms\"] housing[\"population_per_house\"] = housing[\"population\"] / housing[\"households\"] median_house_value 1.000000 median_income 0.688380 rooms_per_house 0.202050 total_rooms 0.137455 housing_median_age 0.102175 households 0.071426 total_bedrooms 0.054635 population -0.020153 population_per_house -0.038224 longitude -0.050859 latitude -0.139584 bedrooms_ratio -0.256397 Name: median_house_value, dtype: float64 기존의 다른 특성들에 비해 bedrooms_ratio, rooms_per_house 특성이 중간 주택 가격과의 상관관계가 높게 나타나는 것을 확인할 수 있다.\n머신러닝 알고리즘을 위한 데이터 준비 머신러닝 알고리즘을 위해 데이터를 준비하는 과정은 함수를 만들어 자동화해야 하는데, 그 이유는 다음과 같다.\n어떤 데이터셋에 대해서도 데이터 변환을 손쉽게 반복할 수 있음. 향후 \b프로젝트에 재사용 가능한 변환 라이브러리를 점진적으로 구축할 수 있음. 실제 시스템에서 알고리즘에 새 데이터를 주입하기 전에 이 함수를 사용해 변환할 수 있음. 여러 가지 데이터 변환을 쉽게 시도해볼 수 있고 어떤 조합이 가장 좋은지 확인하는 데 편리함. 데이터 정제 먼저, total_bedrooms 특성에 값이 없는 경우가 있는데, 이를 수정해보자. 방법에는 다음과 같이 세 가지가 있다.\n해당 구역을 제거하기 전체 특성을 삭제하기 대체 : 누락된 갓을 어떤 값으로 채우기 판다스의 dropana(), drop(), fillna() 메서드로 이런 작업을 간단하게 처리할 수 있다.\n# housing.dropna(subset=[\"total_bedrooms\"], inplace=True) # housing.drop(\"total_bedrooms\", axis=1, inplace=True) median = housing[\"total_bedrooms\"].median() housing[\"total_bedrooms\"].fillna(median, inplace=True) 데이터 정제 먼저, total_bedrooms 특성에 값이 없는 경우가 있는데, 이를 수정해보자. 방법에는 다음과 같이 세 가지가 있다.\n해당 구역을 제거하기 전체 특성을 삭제하기 대체 : 누락된 값을 어떤 값으로 채우기 판다스의 dropana(), drop(), fillna() 메서드로 이런 작업을 간단하게 처리할 수 있다.\n# housing.dropna(subset=[\"total_bedrooms\"], inplace=True) # housing.drop(\"total_bedrooms\", axis=1, inplace=True) median = housing[\"total_bedrooms\"].median() housing[\"total_bedrooms\"].fillna(median, inplace=True) 여기까지는 저번 파트에서 다루었던 내용이다.\n세 번째 옵션이 누락된 값을 중간값으로 채우는 코드이다. 위와 같은 동작을 사이킷런의 SimpleImputer 클래스를 통해 할 수 있다. 이 클래스는 각 특성의 중간값을 저장하고 있어 유용하다. 또한, 훈련 세트뿐만 아니라 검증 세트와 테스트 세트 그리고 모델에 주입될 새로운 데이터에 있는 누락된 값을 대체할 수 있다.\n다음과 같이 누락된 값을 특성의 중간값으로 대체하도록 지정하여 SimpleImputer의 객체를 생성한다.\nfrom sklearn.impute import SimpleImputer imputer = SimpleImputer(strategy=\"median\") 중간값은 수치형 특성에서만 계산될 수 있으므로 수치 특성만 가진 데이터 복사본을 생성한다.\nhousing_num = housing.select_dtypes(include=[np.number]) 이후, imputer 객체의 fit() 메서드를 사용해 훈련 데이터에 적용할 수 있다.\nimputer.fit(housing_num) imputer은 각 특성의 중간값을 계산하여 그 결과를 객체의 statistics_ 속성에 저장한다. 이후, 학습된 impuer 객체를 사용해 훈련 세트에서 누락된 값을 학습된 중간값으로 바꿀 수 있다.\nX = imputer.transform(housing_num) 누락된 값을 평균이나 가장 자주 등장하는 값, 상수로 바꾸는 것도 가능하다. 뒤 두 가지 방법은 수치가 아닌 데이터도 지원한다.\n사이킷런 변환기는 판다스 데이터프레임이 입력되더라도 넘파이 배열이나 사이파이 희소 행렬을 출력한다. 따라서 imputer.transform(housing_num) 의 출력 또한 넘파이 배열이다.\ntype(X) \u003e\u003e numpy.ndarray 현재 상태에서는 열 이름도 인덱스도 없기 때문에, 이를 데이터프레임으로 감싸서 열 이름과 인덱스를 복원할 수 있다.\nhousing_tr = pd.DataFrame(X, columns=housing_num.columns, index=housing_num.index) 텍스트와 범주형 특성 다루기 위에서는 수치형 특성만을 다뤘고, 이제는 텍스트 특성을 살펴보자.\nhousing_cat = housing[[\"ocean_proximity\"]] housing_cat.head(8) ocean_proximity 13096 NEAR BAY 14973 \u003c1H OCEAN 3785 INLAND 14689 INLAND 20507 NEAR OCEAN 1286 INLAND 18078 \u003c1H OCEAN 4396 NEAR BAY housing_cat.value_counts() ocean_proximity \u003c1H OCEAN 7274 INLAND 5301 NEAR OCEAN 2089 NEAR BAY 1846 ISLAND 2 Name: count, dtype: int64 이를 통해, 이 특성은 범주형 특성임을 알 수 있다.\n이 카테고리를 텍스트에서 숫자로 변환하기 위해 사이킷런의 OrdinalEncoder을 사용한다.\nfrom sklearn.preprocessing import OrdinalEncoder ordinal_encoder = OrdinalEncoder() housing_cat_encoded = ordinal_encoder.fit_transform(housing_cat) 인코딩된 몇 개의 값을 확인하면 다음과 같다.\nhousing_cat_encoded[:8] array([[3.], [0.], [1.], [1.], [4.], [1.], [0.], [3.]]) categories_ 인스턴스 변수를 사용해 카테고리 리스트를 얻을 수 있다. 범주형 특성마다 1D 카테고리 배열을 담은 리스트가 반환된다.\nordinal_encoder.categories_ [array(['\u003c1H OCEAN', 'INLAND', 'ISLAND', 'NEAR BAY', 'NEAR OCEAN'], dtype=object)] 이런 표현 방식의 문제는 머신러닝 알고리즘이 가까이 있는 두 값을 떨어져 있는 두 값보다 더 비슷하다고 생각한다는 점이다. (숫자 상으로 비슷하면, 실제로는 전혀 다른 특징을 가진 값이어도 비슷하게 인식하게 된다.)\n이러한 문제는 카테고리별 이진 특성을 만들어 해결한다. 카테고리가 \u003c1H OCEAN일 때 한 특성이 1이고, 카테고리가 INLAND일 때 다른 한 특성이 1이 되는 식이다. 한 특성만 1이고 나머지는 0이므로 이를 원-핫 인코딩이라고 부른다. 새로운 특성을 더미 특성이라고도 부른다. 사이킷런은 범주 값을 원-핫 벡터로 바꾸기 위한 OneHotEncoder 클래스를 제공한다.\nfrom sklearn.preprocessing import OneHotEncoder cat_encoder = OneHotEncoder() housing_cat_1hot = cat_encoder.fit_transform(housing_cat) OneHotEncoder의 출력은 넘파이 배열이 아니라 사이파이 희소 행렬이다.\nhousing_cat_1hot \u003c16512x5 sparse matrix of type '","wordCount":"1727","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-07-14T00:00:00Z","dateModified":"2025-07-14T00:00:00Z","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/handson_chap2/"},"publisher":{"@type":"Organization","name":"CS Playground","logo":{"@type":"ImageObject","url":"http://localhost:1313/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=archives><span>archives</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">핸즈온 머신러닝 - 2장</h1><div class=post-meta><span title='2025-07-14 00:00:00 +0000 UTC'>July 14, 2025</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>Me</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/%3cpath_to_repo%3e/content/posts/handson_chap2.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#큰-그림-보기>큰 그림 보기</a><ul><li><a href=#문제-정의>문제 정의</a></li><li><a href=#성능-측정-지표-선택>성능 측정 지표 선택</a></li><li><a href=#가정-검사>가정 검사</a></li></ul></li><li><a href=#데이터-가져오기>데이터 가져오기</a><ul><li><a href=#데이터-다운로드>데이터 다운로드</a></li><li><a href=#데이터-구조-훑어보기>데이터 구조 훑어보기</a></li><li><a href=#테스트-세트-만들기>테스트 세트 만들기</a></li><li><a href=#데이터-이해를-위한-탐색과-시각화>데이터 이해를 위한 탐색과 시각화</a></li><li><a href=#상관관계-조사하기>상관관계 조사하기</a></li><li><a href=#특성-조합으로-실험하기>특성 조합으로 실험하기</a></li></ul></li><li><a href=#머신러닝-알고리즘을-위한-데이터-준비>머신러닝 알고리즘을 위한 데이터 준비</a><ul><li><a href=#데이터-정제>데이터 정제</a></li><li><a href=#데이터-정제-1>데이터 정제</a></li><li><a href=#텍스트와-범주형-특성-다루기>텍스트와 범주형 특성 다루기</a></li></ul></li></ul></nav></div></details></div><div class=post-content><blockquote><p>2장에서는 캘리포니아 주택 가격 데이터셋을 활용해 머신러닝 프로젝트를 처음부터 끝까지 직접 진행해보면서 배우는 것을 목표로 한다.</p></blockquote><h2 id=큰-그림-보기>큰 그림 보기<a hidden class=anchor aria-hidden=true href=#큰-그림-보기>#</a></h2><h3 id=문제-정의>문제 정의<a hidden class=anchor aria-hidden=true href=#문제-정의>#</a></h3><p>풀고자 하는 문제가 무엇인지 먼저 정의하는 것이 필요함. 그렇게 하여 문제 상황을 정확히 파악하고, 해당 문제에 적합한 시스템을 설계하게 됨.
지금 문제는 레이블된 훈련 샘플이 있고, 여러 특성을 통해 한 개의 값을 예측하므로 <strong>지도 학습, 단변량 회귀</strong> 문제가 됨.</p><h3 id=성능-측정-지표-선택>성능 측정 지표 선택<a hidden class=anchor aria-hidden=true href=#성능-측정-지표-선택>#</a></h3><p>회귀 문제에서는 일반적으로 평균 제곱근 오차, <code>RMSE</code>를 사용한다.
$RMSE(X, h) = \sqrt{\frac{1}{m} \sum_{i=1}^{n} (h(x^{(i)}) - y^{(i)})^2}$</p><p>하지만, <strong>이상치로 보이는 구역이 많은 경우</strong>, 평균 절대 오차, <code>MAE</code>를 사용하기도 한다.
$MAE(X, h) = \frac{1}{m}\sum_{i=1}^{m}|h(x^{(i)})-y^{(i)}|$</p><p>둘 모두 예측값의 벡터와 타깃값의 벡터 사이의 거리를 재는 방식이다. 거리 측정에는 여러 방식을 사용할 수 있다.</p><ul><li><strong>유클리드 노름</strong> : <code>RMSE</code> 계산과 같다. $l_2$ 노름이라고도 부른다.</li><li><strong>맨해튼 노름</strong> : 절댓값의 합을 계산한다. $l_1$ 노름이라고도 부른다.</li><li>$l_k$ 노름 = $(|v_0|^k + |v_1|^k + &mldr; + |v_n|^k)^{\frac{1}{k}}$</li></ul><h3 id=가정-검사>가정 검사<a hidden class=anchor aria-hidden=true href=#가정-검사>#</a></h3><p>시스템에서 요구로 출력을 하고 있는 출력이 현재 개발하고자 하는 모델의 출력과 일치한지 (ex: 가정에서는 수치형을 출력하고자 하는데 범주형을 요구한다던가) 확인해야한다.</p><h2 id=데이터-가져오기>데이터 가져오기<a hidden class=anchor aria-hidden=true href=#데이터-가져오기>#</a></h2><h3 id=데이터-다운로드>데이터 다운로드<a hidden class=anchor aria-hidden=true href=#데이터-다운로드>#</a></h3><p>아래 코드를 실행하면 데이터를 다운로드 할 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pathlib</span> <span class=kn>import</span> <span class=n>Path</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>pandas</span> <span class=k>as</span> <span class=nn>pd</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>tarfile</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>urllib.request</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>load_housing_data</span><span class=p>():</span>
</span></span><span class=line><span class=cl>    <span class=n>tarball_path</span> <span class=o>=</span> <span class=n>Path</span><span class=p>(</span><span class=s2>&#34;datasets/housing.tgz&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=ow>not</span> <span class=n>tarball_path</span><span class=o>.</span><span class=n>is_file</span><span class=p>():</span>
</span></span><span class=line><span class=cl>        <span class=n>Path</span><span class=p>(</span><span class=s2>&#34;datasets&#34;</span><span class=p>)</span><span class=o>.</span><span class=n>mkdir</span><span class=p>(</span><span class=n>parents</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>exist_ok</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=n>url</span> <span class=o>=</span> <span class=s2>&#34;https://github.com/ageron/data/raw/main/housing.tgz&#34;</span>
</span></span><span class=line><span class=cl>        <span class=n>urllib</span><span class=o>.</span><span class=n>request</span><span class=o>.</span><span class=n>urlretrieve</span><span class=p>(</span><span class=n>url</span><span class=p>,</span> <span class=n>tarball_path</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=n>tarfile</span><span class=o>.</span><span class=n>open</span><span class=p>(</span><span class=n>tarball_path</span><span class=p>)</span> <span class=k>as</span> <span class=n>housing_tarball</span><span class=p>:</span>
</span></span><span class=line><span class=cl>            <span class=n>housing_tarball</span><span class=o>.</span><span class=n>extractall</span><span class=p>(</span><span class=n>path</span><span class=o>=</span><span class=s2>&#34;datasets&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>pd</span><span class=o>.</span><span class=n>read_csv</span><span class=p>(</span><span class=s2>&#34;datasets/housing/housing.csv&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>housing</span> <span class=o>=</span> <span class=n>load_housing_data</span><span class=p>()</span>
</span></span></code></pre></div><ol><li><code>tarball_path</code>에 있는 파일이 있는지 확인한다.
1-1. 만약 파일이 없다면, <code>datasets</code> 폴더를 만들고 그 폴더에 <code>tgz</code> 파일을 다운로드받은 뒤, 압축 해제를 한다.</li><li>파일을 pandas DataFrame으로 읽어온 결과를 리턴한다.</li></ol><h3 id=데이터-구조-훑어보기>데이터 구조 훑어보기<a hidden class=anchor aria-hidden=true href=#데이터-구조-훑어보기>#</a></h3><p><code>head()</code> 메서드를 사용하면 데이터의 첫 다섯 행을 읽어올 수 있다.
<img loading=lazy src=https://velog.velcdn.com/images/chae-jpg/post/c1c752c8-baad-4353-b685-d6ce992c5b6c/image.png></p><p><code>info()</code> 메서드는 데이터에 관한 간략한 설명을 보여준다.
특히, 전체 행 수, 각 특성의 데이터 타입, 널이 아닌 값의 개수를 확인하는 데 유용하다.
<img loading=lazy src=https://velog.velcdn.com/images/chae-jpg/post/69e622c6-e4ad-455c-bb34-8bca5374f218/image.png></p><p>다음과 같은 정보를 알 수 있다.</p><ul><li>전체 샘플 개수는 20640개이다.</li><li><code>total_bedrooms</code>는 20433개만 널값이 아니다. 즉, 나머지 207개는 이 특성을 가지고 있지 않다.</li><li><code>ocean_proximity</code> 필드를 제외한 모든 특성이 숫자형이다.</li></ul><hr><p><code>value_counts()</code> 메서드는 어떤 카테고리가 있고, 각 카테고리마다 얼마나 많은 구역이 있는지 확인할 수 있다.
<img loading=lazy src=https://velog.velcdn.com/images/chae-jpg/post/d765883d-39d3-44a6-a553-9916172afc19/image.png></p><p><code>describe</code> 메서드는 숫자형 특성의 요약 정보를 보여준다.</p><p><img loading=lazy src=https://i.imgur.com/XAR1pUi.png></p><p><code>hist()</code> 메서드는 모든 숫자형 형태에 대한 히스토그램을 출력할 수 있다.
<img loading=lazy src=https://i.imgur.com/r711ouE.png></p><p>이를 통해 알 수 있는 사실은 다음과 같다.</p><ul><li>중간 소득이 US 달러로 표시되어 있지 않다. 따라서, 그 단위를 통일하는 것이 필요하다.</li><li>중간 주택 연도와 중간 주택 가격 그래프의 오른쪽 값이 심하게 높아지면서 그래프가 끝나는 것으로 보아 최댓값과 최솟값이 한정되어 있음을 알 수 있다.</li><li>특성들의 스케일이 많이 다르다.</li><li>많은 히스토그램에서 오른쪽 꼬리가 더 길다. 이러한 형태는 일부 머신러닝 알고리즘에서 패턴을 찾기 어렵게 만든다.</li></ul><h3 id=테스트-세트-만들기>테스트 세트 만들기<a hidden class=anchor aria-hidden=true href=#테스트-세트-만들기>#</a></h3><ul><li><strong>데이터 스누핑</strong> 편향 : 테스트 세트로 일반화 오차를 추정하여 매우 낙관적인 추정이 나오게 되는 것</li></ul><p>다음과 같은 코드로 랜덤으로 테스트 세트를 만들 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>import</span> <span class=nn>numpy</span> <span class=k>as</span> <span class=nn>np</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>shuffle_and_split_data</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>test_ratio</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>shuffled_indices</span> <span class=o>=</span> <span class=n>np</span><span class=o>.</span><span class=n>random</span><span class=o>.</span><span class=n>permutation</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>data</span><span class=p>))</span> <span class=c1># 괄호 안 숫자 범위로 생성된 배열을 무작위로 섞음.</span>
</span></span><span class=line><span class=cl>    <span class=n>test_set_size</span> <span class=o>=</span> <span class=nb>int</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=n>data</span><span class=p>)</span> <span class=o>*</span> <span class=n>test_ratio</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>test_indices</span> <span class=o>=</span> <span class=n>shuffled_indices</span><span class=p>[:</span><span class=n>test_set_size</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>train_indices</span> <span class=o>=</span> <span class=n>shuffled_indices</span><span class=p>[</span><span class=n>test_set_size</span><span class=p>:]</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>data</span><span class=o>.</span><span class=n>iloc</span><span class=p>[</span><span class=n>train_indices</span><span class=p>],</span> <span class=n>data</span><span class=o>.</span><span class=n>iloc</span><span class=p>[</span><span class=n>test_indices</span><span class=p>]</span>
</span></span></code></pre></div><p>하지만, <strong>프로그램을 실행할 때마다 다른 테스트 세트가 생성된다</strong>는 문제점이 존재한다. 이를 해결하기 위해서는,</p><ol><li>처음 실행에서 테스트 세트를 저장하고 다음번 실행에서 불러들이기</li><li>항상 같은 난수 인덱스가 생성되도록 <code>np.random.permutation()</code>을 호출하기 전에 난수 발생기의 초깃값을 지정하기</li></ol><p>하지만 위 방법 또한 데이터셋이 업데이트된 경우 문제가 생긴다. 따라서, 샘플의 식별자를 사용하여 테스트 세트로 보낼지 말지를 결정할 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>zlib</span> <span class=kn>import</span> <span class=n>crc32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>is_id_in_test_set</span><span class=p>(</span><span class=n>identifier</span><span class=p>,</span> <span class=n>test_ratio</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>crc32</span><span class=p>(</span><span class=n>np</span><span class=o>.</span><span class=n>int64</span><span class=p>(</span><span class=n>identifier</span><span class=p>)</span><span class=o>.</span><span class=n>tobytes</span><span class=p>())</span> <span class=o>&lt;</span> <span class=n>test_ratio</span> <span class=o>*</span> <span class=mi>2</span> <span class=o>**</span> <span class=mi>32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>def</span> <span class=nf>split_data_with_id_hash</span><span class=p>(</span><span class=n>data</span><span class=p>,</span> <span class=n>test_ratio</span><span class=p>,</span> <span class=n>id_column</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=n>ids</span> <span class=o>=</span> <span class=n>data</span><span class=p>[</span><span class=n>id_column</span><span class=p>]</span>
</span></span><span class=line><span class=cl>    <span class=n>in_test_set</span> <span class=o>=</span> <span class=n>ids</span><span class=o>.</span><span class=n>apply</span><span class=p>(</span><span class=k>lambda</span> <span class=n>id_</span><span class=p>:</span> <span class=n>is_id_in_test_set</span><span class=p>(</span><span class=n>id_</span><span class=p>,</span> <span class=n>test_ratio</span><span class=p>))</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>data</span><span class=o>.</span><span class=n>loc</span><span class=p>[</span><span class=o>~</span><span class=n>in_test_set</span><span class=p>],</span> <span class=n>data</span><span class=o>.</span><span class=n>loc</span><span class=p>[</span><span class=n>in_test_set</span><span class=p>]</span>
</span></span></code></pre></div><p>위 방법을 통해 나눈 훈련 / 테스트 세트를 보면 다음과 같다.</p><p><img loading=lazy src=https://i.imgur.com/gTLpeMA.png></p><hr><p>사이킷런을 사용하면 위 과정을 간단히 구현할 수 있다. 가장 간단한 함수는 <code>train_test_split</code>으로, <em>난수 초깃값을 설정하는 기능</em>과 <em>행의 개수가 같은 여러 개의 데이터셋을 넘겨 동일한 인덱스를 기반으로 나누는 기능</em>이 존재한다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>sklearn.model_selection</span> <span class=kn>import</span> <span class=n>train_test_split</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>train_set</span><span class=p>,</span> <span class=n>test_set</span> <span class=o>=</span> <span class=n>train_test_split</span><span class=p>(</span><span class=n>housing</span><span class=p>,</span> <span class=n>test_size</span><span class=o>=</span><span class=mf>0.2</span><span class=p>,</span> <span class=n>random_state</span><span class=o>=</span><span class=mi>42</span><span class=p>)</span>
</span></span></code></pre></div><hr><p>앞서 본 샘플링은 <strong>순수한 랜덤 샘플링</strong>이다. 데이터셋이 충분히 크다면 괜찮지만, 그렇지 않다면 샘플링 편향이 생길 가능성이 크다. 이를 위해 <strong>계층적 샘플링</strong>이 존재한다.</p><ul><li><strong>계층적 샘플링</strong> : 전체를 <em>계층</em>이라는 동질의 그룹으로 나누고, 테스트 세트가 전체를 대표할 수 있도록 각 계층에서 올바른 수의 샘플을 추출하는 것.</li></ul><p>이를 위해 전체를 여러 개의 계층으로 나눈 뒤, 계층의 비율대로 전체에서 샘플링하는 것이 가능하다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>housing</span><span class=p>[</span><span class=s2>&#34;income_cat&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>cut</span><span class=p>(</span><span class=n>housing</span><span class=p>[</span><span class=s2>&#34;median_income&#34;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>    <span class=n>bins</span><span class=o>=</span><span class=p>[</span><span class=mf>0.</span><span class=p>,</span> <span class=mf>1.5</span><span class=p>,</span> <span class=mf>3.0</span><span class=p>,</span> <span class=mf>4.5</span><span class=p>,</span> <span class=mf>6.</span><span class=p>,</span> <span class=n>np</span><span class=o>.</span><span class=n>inf</span><span class=p>],</span>
</span></span><span class=line><span class=cl>	<span class=n>labels</span><span class=o>=</span><span class=p>[</span><span class=mi>1</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=mi>5</span><span class=p>])</span>
</span></span></code></pre></div><p><a href=https://pandas.pydata.org/docs/reference/api/pandas.cut.html>pandas.cut reference</a>
<code>pandas.cut</code> 함수는 특정 1차원 배열을 <code>bins</code>에 따라 해당 개수, 또는 해당 구간에 따라 분할한 뒤, 각 값들에 대해 해당하는 구간의 <code>labels</code>의 값을 부여한다.
사이킷런의 <code>sklearn.model_selection</code> 패키지 안에는 여러 가지 분할기 클래스를 제공한다. 모든 분할기는 또한 훈련과 테스트 분할에 대한 반복자를 반환하는 <code>split()</code> 메소드를 가지고 있다.</p><p>이 코드에서는 <code>StratifiedShuffleSplit</code>을 사용해 10개의 다른 계층 분할을 생성한다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>sklearn.model_selection</span> <span class=kn>import</span> <span class=n>StratifiedShuffleSplit</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>splitter</span> <span class=o>=</span> <span class=n>StratifiedShuffleSplit</span><span class=p>(</span><span class=n>n_splits</span><span class=o>=</span><span class=mi>10</span><span class=p>,</span> <span class=n>test_size</span><span class=o>=</span><span class=mf>0.2</span><span class=p>,</span> <span class=n>random_state</span><span class=o>=</span><span class=mi>42</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>strat_splits</span> <span class=o>=</span> <span class=p>[]</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>train_index</span><span class=p>,</span> <span class=n>test_index</span> <span class=ow>in</span> <span class=n>splitter</span><span class=o>.</span><span class=n>split</span><span class=p>(</span><span class=n>housing</span><span class=p>,</span> <span class=n>housing</span><span class=p>[</span><span class=s2>&#34;income_cat&#34;</span><span class=p>]):</span>
</span></span><span class=line><span class=cl>	<span class=n>strat_train_set_n</span> <span class=o>=</span> <span class=n>housing</span><span class=o>.</span><span class=n>iloc</span><span class=p>[</span><span class=n>train_index</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=n>strat_test_set_n</span> <span class=o>=</span> <span class=n>housing</span><span class=o>.</span><span class=n>iloc</span><span class=p>[</span><span class=n>test_index</span><span class=p>]</span>
</span></span><span class=line><span class=cl>	<span class=n>strat_splits</span><span class=o>.</span><span class=n>append</span><span class=p>([</span><span class=n>strat_train_set_n</span><span class=p>,</span> <span class=n>strat_test_set_n</span><span class=p>])</span>
</span></span></code></pre></div><p>첫 번째 분할을 다음과 같이 사용할 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>strat_train_set</span><span class=p>,</span> <span class=n>strat_test_set</span> <span class=o>=</span> <span class=n>strat_splits</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span>
</span></span></code></pre></div><p>다음과 같은 방식으로 계층적 샘플링을 코드 한 줄로 불러오는 것도 가능하다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>strat_train_set</span><span class=p>,</span> <span class=n>strat_test_set</span> <span class=o>=</span> <span class=n>train_test_split</span><span class=p>(</span><span class=n>housing</span><span class=p>,</span> <span class=n>test_size</span><span class=o>=</span><span class=mf>0.2</span><span class=p>,</span> <span class=n>stratify</span><span class=o>=</span><span class=n>housing</span><span class=p>[</span><span class=s2>&#34;income_cat&#34;</span><span class=p>],</span> <span class=n>random_state</span><span class=o>=</span><span class=mi>42</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=데이터-이해를-위한-탐색과-시각화>데이터 이해를 위한 탐색과 시각화<a hidden class=anchor aria-hidden=true href=#데이터-이해를-위한-탐색과-시각화>#</a></h3><p>먼저, 다음과 같은 코드를 통해 지리 정보를 산점도로 만들어 시각화해보자.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>housing</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>kind</span><span class=o>=</span><span class=s2>&#34;scatter&#34;</span><span class=p>,</span> <span class=n>x</span><span class=o>=</span><span class=s2>&#34;longitude&#34;</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=s2>&#34;latitude&#34;</span><span class=p>,</span> <span class=n>grid</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>plt</span><span class=o>.</span><span class=n>xlabel</span><span class=p>(</span><span class=s2>&#34;경도&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>plt</span><span class=o>.</span><span class=n>ylabel</span><span class=p>(</span><span class=s2>&#34;위도&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>plt</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
</span></span></code></pre></div><p><img loading=lazy src=https://i.imgur.com/68dJHTL.png></p><p>이 그래프에서, 데이터 포인트가 밀접된 영역을 확인해보자.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>housing</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>kind</span><span class=o>=</span><span class=s2>&#34;scatter&#34;</span><span class=p>,</span> <span class=n>x</span><span class=o>=</span><span class=s2>&#34;longitude&#34;</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=s2>&#34;latitude&#34;</span><span class=p>,</span> <span class=n>grid</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>alpha</span><span class=o>=</span><span class=mf>0.2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>plt</span><span class=o>.</span><span class=n>xlabel</span><span class=p>(</span><span class=s2>&#34;logitude&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>plt</span><span class=o>.</span><span class=n>ylabel</span><span class=p>(</span><span class=s2>&#34;latitude&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>plt</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
</span></span></code></pre></div><p><img loading=lazy src=https://i.imgur.com/SlD9new.png></p><p>다음으로는 구역의 인구와 주택가격까지 그림에 나타내보자.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>housing</span><span class=o>.</span><span class=n>plot</span><span class=p>(</span><span class=n>kind</span><span class=o>=</span><span class=s2>&#34;scatter&#34;</span><span class=p>,</span> <span class=n>x</span><span class=o>=</span><span class=s2>&#34;longitude&#34;</span><span class=p>,</span> <span class=n>y</span><span class=o>=</span><span class=s2>&#34;latitude&#34;</span><span class=p>,</span> <span class=n>grid</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			 <span class=n>s</span><span class=o>=</span><span class=n>housing</span><span class=p>[</span><span class=s2>&#34;population&#34;</span><span class=p>]</span> <span class=o>/</span> <span class=mi>100</span><span class=p>,</span> <span class=n>label</span><span class=o>=</span><span class=s2>&#34;population&#34;</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			 <span class=n>c</span><span class=o>=</span><span class=s2>&#34;median_house_value&#34;</span><span class=p>,</span> <span class=n>cmap</span><span class=o>=</span><span class=s2>&#34;jet&#34;</span><span class=p>,</span> <span class=n>colorbar</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span>
</span></span><span class=line><span class=cl>			 <span class=n>legend</span><span class=o>=</span><span class=kc>True</span><span class=p>,</span> <span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>10</span><span class=p>,</span> <span class=mi>7</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=n>plt</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
</span></span></code></pre></div><p><img loading=lazy src=https://i.imgur.com/Czh9CEq.png></p><h3 id=상관관계-조사하기>상관관계 조사하기<a hidden class=anchor aria-hidden=true href=#상관관계-조사하기>#</a></h3><p>모든 특성 간의 <strong>표준 상관계수</strong>를 <code>corr()</code> 메서드를 사용해 쉽게 계산할 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>corr_matrix</span><span class=p>[</span><span class=s2>&#34;median_house_value&#34;</span><span class=p>]</span><span class=o>.</span><span class=n>sort_values</span><span class=p>(</span><span class=n>ascending</span><span class=o>=</span><span class=kc>False</span><span class=p>)</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>median_house_value    1.000000
</span></span><span class=line><span class=cl>median_income         0.688380
</span></span><span class=line><span class=cl>total_rooms           0.137455
</span></span><span class=line><span class=cl>housing_median_age    0.102175
</span></span><span class=line><span class=cl>households            0.071426
</span></span><span class=line><span class=cl>total_bedrooms        0.054635
</span></span><span class=line><span class=cl>population           -0.020153
</span></span><span class=line><span class=cl>longitude            -0.050859
</span></span><span class=line><span class=cl>latitude             -0.139584
</span></span><span class=line><span class=cl>Name: median_house_value, dtype: float64
</span></span></code></pre></div><p>상관관계의 범위는 -1부터 1까지로, 1에 가까우면 강한 양의 상관관계, -1에 가까우면 강한 음의 상관관계를 가진다는 뜻이다.</p><p>판다스의 <code>scatter_matrix</code> 함수를 통해 숫자형 특성 간 산점도를 그려보는 것 또한 가능하다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>pandas.plotting</span> <span class=kn>import</span> <span class=n>scatter_matrix</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=n>attributes</span> <span class=o>=</span> <span class=p>[</span><span class=s2>&#34;median_house_value&#34;</span><span class=p>,</span> <span class=s2>&#34;median_income&#34;</span><span class=p>,</span> <span class=s2>&#34;total_rooms&#34;</span><span class=p>,</span>   
</span></span><span class=line><span class=cl><span class=s2>&#34;housing_median_age&#34;</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=n>scatter_matrix</span><span class=p>(</span><span class=n>housing</span><span class=p>[</span><span class=n>attributes</span><span class=p>],</span> <span class=n>figsize</span><span class=o>=</span><span class=p>(</span><span class=mi>12</span><span class=p>,</span> <span class=mi>8</span><span class=p>))</span>  
</span></span><span class=line><span class=cl><span class=n>plt</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
</span></span></code></pre></div><p><img loading=lazy src=https://i.imgur.com/Ou17vi8.png></p><p>이 그림을 보았을 때, 중간 주택 가격을 예측하는 데 중간 소득이 가장 유용해보인다는 것을 발견할 수 있다. 이 산점도를 확대해보자.</p><p><img loading=lazy src=https://i.imgur.com/srlcADH.png></p><p>이 그래프를 통해 알 수 있는 사실은 다음과 같다.</p><ol><li>상관관계가 매우 강하다.<ul><li>위쪽으로 향하는 경향이 보인다.</li><li>포인트들이 너무 많이 퍼져 있지는 않다.</li></ul></li><li>가격의 한계값이 수평선으로 잘 보이는데, 이러한 형태가 다른 곳에서도 더 나타나므로 이상한 형태를 알고리즘이 학습하지 않도록 구역을 제거할 수 있다.</li></ol><h3 id=특성-조합으로-실험하기>특성 조합으로 실험하기<a hidden class=anchor aria-hidden=true href=#특성-조합으로-실험하기>#</a></h3><p>특정 구역의 가구 당 방 개수가 몇 개인지, 방 당 침실 개수가 몇 개인지 등 여러 특성을 조합하여 새로운 특성을 만들 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>housing</span><span class=p>[</span><span class=s2>&#34;rooms_per_house&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>housing</span><span class=p>[</span><span class=s2>&#34;total_rooms&#34;</span><span class=p>]</span> <span class=o>/</span> <span class=n>housing</span><span class=p>[</span><span class=s2>&#34;population&#34;</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=n>housing</span><span class=p>[</span><span class=s2>&#34;bedrooms_ratio&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>housing</span><span class=p>[</span><span class=s2>&#34;total_bedrooms&#34;</span><span class=p>]</span> <span class=o>/</span> <span class=n>housing</span><span class=p>[</span><span class=s2>&#34;total_rooms&#34;</span><span class=p>]</span>  
</span></span><span class=line><span class=cl><span class=n>housing</span><span class=p>[</span><span class=s2>&#34;population_per_house&#34;</span><span class=p>]</span> <span class=o>=</span> <span class=n>housing</span><span class=p>[</span><span class=s2>&#34;population&#34;</span><span class=p>]</span> <span class=o>/</span> <span class=n>housing</span><span class=p>[</span><span class=s2>&#34;households&#34;</span><span class=p>]</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>median_house_value      1.000000
</span></span><span class=line><span class=cl>median_income           0.688380
</span></span><span class=line><span class=cl>rooms_per_house         0.202050
</span></span><span class=line><span class=cl>total_rooms             0.137455
</span></span><span class=line><span class=cl>housing_median_age      0.102175
</span></span><span class=line><span class=cl>households              0.071426
</span></span><span class=line><span class=cl>total_bedrooms          0.054635
</span></span><span class=line><span class=cl>population             -0.020153
</span></span><span class=line><span class=cl>population_per_house   -0.038224
</span></span><span class=line><span class=cl>longitude              -0.050859
</span></span><span class=line><span class=cl>latitude               -0.139584
</span></span><span class=line><span class=cl>bedrooms_ratio         -0.256397
</span></span><span class=line><span class=cl>Name: median_house_value, dtype: float64
</span></span></code></pre></div><p>기존의 다른 특성들에 비해 <code>bedrooms_ratio</code>, <code>rooms_per_house</code> 특성이 중간 주택 가격과의 상관관계가 높게 나타나는 것을 확인할 수 있다.</p><h2 id=머신러닝-알고리즘을-위한-데이터-준비>머신러닝 알고리즘을 위한 데이터 준비<a hidden class=anchor aria-hidden=true href=#머신러닝-알고리즘을-위한-데이터-준비>#</a></h2><p>머신러닝 알고리즘을 위해 데이터를 준비하는 과정은 함수를 만들어 자동화해야 하는데, 그 이유는 다음과 같다.</p><ul><li>어떤 데이터셋에 대해서도 데이터 변환을 손쉽게 반복할 수 있음.</li><li>향후 프로젝트에 재사용 가능한 변환 라이브러리를 점진적으로 구축할 수 있음.</li><li>실제 시스템에서 알고리즘에 새 데이터를 주입하기 전에 이 함수를 사용해 변환할 수 있음.</li><li>여러 가지 데이터 변환을 쉽게 시도해볼 수 있고 어떤 조합이 가장 좋은지 확인하는 데 편리함.</li></ul><h3 id=데이터-정제>데이터 정제<a hidden class=anchor aria-hidden=true href=#데이터-정제>#</a></h3><p>먼저, <code>total_bedrooms</code> 특성에 값이 없는 경우가 있는데, 이를 수정해보자. 방법에는 다음과 같이 세 가지가 있다.</p><blockquote><ol><li>해당 구역을 제거하기</li><li>전체 특성을 삭제하기</li><li><strong>대체</strong> : 누락된 갓을 어떤 값으로 채우기</li></ol></blockquote><p>판다스의 <code>dropana()</code>, <code>drop()</code>, <code>fillna()</code> 메서드로 이런 작업을 간단하게 처리할 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># housing.dropna(subset=[&#34;total_bedrooms&#34;], inplace=True)  </span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=c1># housing.drop(&#34;total_bedrooms&#34;, axis=1, inplace=True)  </span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=n>median</span> <span class=o>=</span> <span class=n>housing</span><span class=p>[</span><span class=s2>&#34;total_bedrooms&#34;</span><span class=p>]</span><span class=o>.</span><span class=n>median</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=n>housing</span><span class=p>[</span><span class=s2>&#34;total_bedrooms&#34;</span><span class=p>]</span><span class=o>.</span><span class=n>fillna</span><span class=p>(</span><span class=n>median</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=데이터-정제-1>데이터 정제<a hidden class=anchor aria-hidden=true href=#데이터-정제-1>#</a></h3><p>먼저, <code>total_bedrooms</code> 특성에 값이 없는 경우가 있는데, 이를 수정해보자. 방법에는 다음과 같이 세 가지가 있다.</p><blockquote><ol><li>해당 구역을 제거하기</li><li>전체 특성을 삭제하기</li><li><strong>대체</strong> : 누락된 값을 어떤 값으로 채우기</li></ol></blockquote><p>판다스의 <code>dropana()</code>, <code>drop()</code>, <code>fillna()</code> 메서드로 이런 작업을 간단하게 처리할 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=c1># housing.dropna(subset=[&#34;total_bedrooms&#34;], inplace=True)  </span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=c1># housing.drop(&#34;total_bedrooms&#34;, axis=1, inplace=True)  </span>
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=n>median</span> <span class=o>=</span> <span class=n>housing</span><span class=p>[</span><span class=s2>&#34;total_bedrooms&#34;</span><span class=p>]</span><span class=o>.</span><span class=n>median</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=n>housing</span><span class=p>[</span><span class=s2>&#34;total_bedrooms&#34;</span><span class=p>]</span><span class=o>.</span><span class=n>fillna</span><span class=p>(</span><span class=n>median</span><span class=p>,</span> <span class=n>inplace</span><span class=o>=</span><span class=kc>True</span><span class=p>)</span>
</span></span></code></pre></div><p>여기까지는 저번 파트에서 다루었던 내용이다.</p><hr><p>세 번째 옵션이 누락된 값을 중간값으로 채우는 코드이다.
위와 같은 동작을 사이킷런의 <code>SimpleImputer</code> 클래스를 통해 할 수 있다. 이 클래스는 각 특성의 중간값을 저장하고 있어 유용하다. 또한, 훈련 세트뿐만 아니라 검증 세트와 테스트 세트 그리고 모델에 주입될 새로운 데이터에 있는 누락된 값을 대체할 수 있다.</p><p>다음과 같이 누락된 값을 특성의 중간값으로 대체하도록 지정하여 SimpleImputer의 객체를 생성한다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>sklearn.impute</span> <span class=kn>import</span> <span class=n>SimpleImputer</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=n>imputer</span> <span class=o>=</span> <span class=n>SimpleImputer</span><span class=p>(</span><span class=n>strategy</span><span class=o>=</span><span class=s2>&#34;median&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>중간값은 수치형 특성에서만 계산될 수 있으므로 수치 특성만 가진 데이터 복사본을 생성한다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>housing_num</span> <span class=o>=</span> <span class=n>housing</span><span class=o>.</span><span class=n>select_dtypes</span><span class=p>(</span><span class=n>include</span><span class=o>=</span><span class=p>[</span><span class=n>np</span><span class=o>.</span><span class=n>number</span><span class=p>])</span>
</span></span></code></pre></div><p>이후, imputer 객체의 <code>fit()</code> 메서드를 사용해 훈련 데이터에 적용할 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>imputer</span><span class=o>.</span><span class=n>fit</span><span class=p>(</span><span class=n>housing_num</span><span class=p>)</span>
</span></span></code></pre></div><p>imputer은 각 특성의 중간값을 계산하여 그 결과를 객체의 <code>statistics_</code> 속성에 저장한다.
이후, 학습된 impuer 객체를 사용해 훈련 세트에서 누락된 값을 학습된 중간값으로 바꿀 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>X</span> <span class=o>=</span> <span class=n>imputer</span><span class=o>.</span><span class=n>transform</span><span class=p>(</span><span class=n>housing_num</span><span class=p>)</span>
</span></span></code></pre></div><p>누락된 값을 평균이나 가장 자주 등장하는 값, 상수로 바꾸는 것도 가능하다. 뒤 두 가지 방법은 수치가 아닌 데이터도 지원한다.</p><p>사이킷런 변환기는 판다스 데이터프레임이 입력되더라도 넘파이 배열이나 사이파이 희소 행렬을 출력한다. 따라서 <code>imputer.transform(housing_num)</code> 의 출력 또한 넘파이 배열이다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=nb>type</span><span class=p>(</span><span class=n>X</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&gt;&gt;</span> <span class=n>numpy</span><span class=o>.</span><span class=n>ndarray</span>
</span></span></code></pre></div><p>현재 상태에서는 열 이름도 인덱스도 없기 때문에, 이를 데이터프레임으로 감싸서 열 이름과 인덱스를 복원할 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>housing_tr</span> <span class=o>=</span> <span class=n>pd</span><span class=o>.</span><span class=n>DataFrame</span><span class=p>(</span><span class=n>X</span><span class=p>,</span> <span class=n>columns</span><span class=o>=</span><span class=n>housing_num</span><span class=o>.</span><span class=n>columns</span><span class=p>,</span>  
</span></span><span class=line><span class=cl>                          <span class=n>index</span><span class=o>=</span><span class=n>housing_num</span><span class=o>.</span><span class=n>index</span><span class=p>)</span>
</span></span></code></pre></div><h3 id=텍스트와-범주형-특성-다루기>텍스트와 범주형 특성 다루기<a hidden class=anchor aria-hidden=true href=#텍스트와-범주형-특성-다루기>#</a></h3><p>위에서는 수치형 특성만을 다뤘고, 이제는 텍스트 특성을 살펴보자.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>housing_cat</span> <span class=o>=</span> <span class=n>housing</span><span class=p>[[</span><span class=s2>&#34;ocean_proximity&#34;</span><span class=p>]]</span>  
</span></span><span class=line><span class=cl><span class=n>housing_cat</span><span class=o>.</span><span class=n>head</span><span class=p>(</span><span class=mi>8</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>      <span class=n>ocean_proximity</span>
</span></span><span class=line><span class=cl><span class=mi>13096</span>        <span class=n>NEAR</span> <span class=n>BAY</span>
</span></span><span class=line><span class=cl><span class=mi>14973</span>       <span class=o>&lt;</span><span class=mi>1</span><span class=n>H</span> <span class=n>OCEAN</span>
</span></span><span class=line><span class=cl><span class=mi>3785</span>           <span class=n>INLAND</span>
</span></span><span class=line><span class=cl><span class=mi>14689</span>          <span class=n>INLAND</span>
</span></span><span class=line><span class=cl><span class=mi>20507</span>      <span class=n>NEAR</span> <span class=n>OCEAN</span>
</span></span><span class=line><span class=cl><span class=mi>1286</span>           <span class=n>INLAND</span>
</span></span><span class=line><span class=cl><span class=mi>18078</span>       <span class=o>&lt;</span><span class=mi>1</span><span class=n>H</span> <span class=n>OCEAN</span>
</span></span><span class=line><span class=cl><span class=mi>4396</span>         <span class=n>NEAR</span> <span class=n>BAY</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>housing_cat</span><span class=o>.</span><span class=n>value_counts</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>ocean_proximity</span>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=mi>1</span><span class=n>H</span> <span class=n>OCEAN</span>          <span class=mi>7274</span>
</span></span><span class=line><span class=cl><span class=n>INLAND</span>             <span class=mi>5301</span>
</span></span><span class=line><span class=cl><span class=n>NEAR</span> <span class=n>OCEAN</span>         <span class=mi>2089</span>
</span></span><span class=line><span class=cl><span class=n>NEAR</span> <span class=n>BAY</span>           <span class=mi>1846</span>
</span></span><span class=line><span class=cl><span class=n>ISLAND</span>                <span class=mi>2</span>
</span></span><span class=line><span class=cl><span class=n>Name</span><span class=p>:</span> <span class=n>count</span><span class=p>,</span> <span class=n>dtype</span><span class=p>:</span> <span class=n>int64</span>
</span></span></code></pre></div><p>이를 통해, 이 특성은 범주형 특성임을 알 수 있다.</p><p>이 카테고리를 텍스트에서 숫자로 변환하기 위해 사이킷런의 <code>OrdinalEncoder</code>을 사용한다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>sklearn.preprocessing</span> <span class=kn>import</span> <span class=n>OrdinalEncoder</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=n>ordinal_encoder</span> <span class=o>=</span> <span class=n>OrdinalEncoder</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=n>housing_cat_encoded</span> <span class=o>=</span> <span class=n>ordinal_encoder</span><span class=o>.</span><span class=n>fit_transform</span><span class=p>(</span><span class=n>housing_cat</span><span class=p>)</span>
</span></span></code></pre></div><p>인코딩된 몇 개의 값을 확인하면 다음과 같다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>housing_cat_encoded</span><span class=p>[:</span><span class=mi>8</span><span class=p>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>array</span><span class=p>([[</span><span class=mf>3.</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span><span class=mf>0.</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span><span class=mf>1.</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span><span class=mf>1.</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span><span class=mf>4.</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span><span class=mf>1.</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span><span class=mf>0.</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span><span class=mf>3.</span><span class=p>]])</span>
</span></span></code></pre></div><p><code>categories_</code> 인스턴스 변수를 사용해 카테고리 리스트를 얻을 수 있다. 범주형 특성마다 1D 카테고리 배열을 담은 리스트가 반환된다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>ordinal_encoder</span><span class=o>.</span><span class=n>categories_</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>[</span><span class=n>array</span><span class=p>([</span><span class=s1>&#39;&lt;1H OCEAN&#39;</span><span class=p>,</span> <span class=s1>&#39;INLAND&#39;</span><span class=p>,</span> <span class=s1>&#39;ISLAND&#39;</span><span class=p>,</span> <span class=s1>&#39;NEAR BAY&#39;</span><span class=p>,</span> <span class=s1>&#39;NEAR OCEAN&#39;</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=n>dtype</span><span class=o>=</span><span class=nb>object</span><span class=p>)]</span>
</span></span></code></pre></div><p>이런 표현 방식의 문제는 머신러닝 알고리즘이 가까이 있는 두 값을 떨어져 있는 두 값보다 더 비슷하다고 생각한다는 점이다. (숫자 상으로 비슷하면, 실제로는 전혀 다른 특징을 가진 값이어도 비슷하게 인식하게 된다.)</p><p>이러한 문제는 카테고리별 이진 특성을 만들어 해결한다. 카테고리가 <code>&lt;1H OCEAN</code>일 때 한 특성이 1이고, 카테고리가 <code>INLAND</code>일 때 다른 한 특성이 1이 되는 식이다.
한 특성만 1이고 나머지는 0이므로 이를 <strong>원-핫 인코딩</strong>이라고 부른다. 새로운 특성을 <strong>더미</strong> 특성이라고도 부른다. 사이킷런은 범주 값을 원-핫 벡터로 바꾸기 위한 <code>OneHotEncoder</code> 클래스를 제공한다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=kn>from</span> <span class=nn>sklearn.preprocessing</span> <span class=kn>import</span> <span class=n>OneHotEncoder</span>  
</span></span><span class=line><span class=cl>  
</span></span><span class=line><span class=cl><span class=n>cat_encoder</span> <span class=o>=</span> <span class=n>OneHotEncoder</span><span class=p>()</span>  
</span></span><span class=line><span class=cl><span class=n>housing_cat_1hot</span> <span class=o>=</span> <span class=n>cat_encoder</span><span class=o>.</span><span class=n>fit_transform</span><span class=p>(</span><span class=n>housing_cat</span><span class=p>)</span>
</span></span></code></pre></div><p><code>OneHotEncoder</code>의 출력은 넘파이 배열이 아니라 사이파이 희소 행렬이다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>housing_cat_1hot</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>&lt;</span><span class=mi>16512</span><span class=n>x5</span> <span class=n>sparse</span> <span class=n>matrix</span> <span class=n>of</span> <span class=nb>type</span> <span class=s1>&#39;&lt;class &#39;</span><span class=n>numpy</span><span class=o>.</span><span class=n>float64</span><span class=s1>&#39;&gt;&#39;</span>
</span></span><span class=line><span class=cl>	<span class=k>with</span> <span class=mi>16512</span> <span class=n>stored</span> <span class=n>elements</span> <span class=ow>in</span> <span class=n>Compressed</span> <span class=n>Sparse</span> <span class=n>Row</span> <span class=nb>format</span><span class=o>&gt;</span>
</span></span></code></pre></div><p>희소 행렬은 0이 대부분인 행렬을 매우 효율적으로 표현한다. 내부적으로 0이 아닌 값과 그 위치만 저장한다. 이는 많은 메모리를 절약하고 계산 속도를 높여주는 효과를 가진다. <a href=https://docs.scipy.org/doc/scipy/tutorial/sparse.html>공식 documentation</a></p><p>대부분 희소 행렬을 보통의 2D 배열처럼 사용할 수 있지만, 넘파이 배열로 바꾸려면 <code>toarray()</code> 메서드를 호출해야 한다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-python data-lang=python><span class=line><span class=cl><span class=n>housing_cat_1hot</span><span class=o>.</span><span class=n>toarray</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>array</span><span class=p>([[</span><span class=mf>0.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>,</span> <span class=mf>1.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span><span class=mf>1.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span><span class=mf>0.</span><span class=p>,</span> <span class=mf>1.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=o>...</span><span class=p>,</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span><span class=mf>0.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>,</span> <span class=mf>1.</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span><span class=mf>1.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>],</span>
</span></span><span class=line><span class=cl>       <span class=p>[</span><span class=mf>0.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>,</span> <span class=mf>0.</span><span class=p>,</span> <span class=mf>1.</span><span class=p>]])</span>
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/ml/>ML</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/gpt-1/><span class=title>« Prev</span><br><span>Improving Language Understanding by Generative Pre-Training (GPT-1) 리뷰</span>
</a><a class=next href=http://localhost:1313/posts/jtp_1/><span class=title>Next »</span><br><span>점프 투 파이썬 - 파이썬 날아오르기</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share 핸즈온 머신러닝 - 2장 on x" href="https://x.com/intent/tweet/?text=%ed%95%b8%ec%a6%88%ec%98%a8%20%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d%20-%202%ec%9e%a5&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fhandson_chap2%2f&amp;hashtags=ML"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 핸즈온 머신러닝 - 2장 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fhandson_chap2%2f&amp;title=%ed%95%b8%ec%a6%88%ec%98%a8%20%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d%20-%202%ec%9e%a5&amp;summary=%ed%95%b8%ec%a6%88%ec%98%a8%20%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d%20-%202%ec%9e%a5&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fhandson_chap2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 핸즈온 머신러닝 - 2장 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fhandson_chap2%2f&title=%ed%95%b8%ec%a6%88%ec%98%a8%20%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d%20-%202%ec%9e%a5"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 핸즈온 머신러닝 - 2장 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fhandson_chap2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 핸즈온 머신러닝 - 2장 on whatsapp" href="https://api.whatsapp.com/send?text=%ed%95%b8%ec%a6%88%ec%98%a8%20%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d%20-%202%ec%9e%a5%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fhandson_chap2%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 핸즈온 머신러닝 - 2장 on telegram" href="https://telegram.me/share/url?text=%ed%95%b8%ec%a6%88%ec%98%a8%20%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d%20-%202%ec%9e%a5&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fhandson_chap2%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share 핸즈온 머신러닝 - 2장 on ycombinator" href="https://news.ycombinator.com/submitlink?t=%ed%95%b8%ec%a6%88%ec%98%a8%20%eb%a8%b8%ec%8b%a0%eb%9f%ac%eb%8b%9d%20-%202%ec%9e%a5&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fhandson_chap2%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>CS Playground</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>