<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>BOJ 19640 - 화장실의 규칙 | CS Playground</title><meta name=keywords content><meta name=description content="시뮬레이션, 우선순위 큐"><meta name=author content="Me"><link rel=canonical href=http://localhost:1313/posts/boj_19640/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.a090830a421002426baafbd314e38f149d77b4c48a12ee9312700d770b27fb26.css integrity="sha256-oJCDCkIQAkJrqvvTFOOPFJ13tMSKEu6TEnANdwsn+yY=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicons/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicons/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=http://localhost:1313/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/boj_19640/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css integrity=sha384-MlJdn/WNKDGXveldHDdyRP1R4CTHr3FeuDNfhsLPYrq2t0UBkUdK2jyTnXPEK1NQ crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js integrity=sha384-VQ8d8WVFw0yHhCk5E8I86oOhv48xLpnDZx5T9GogA/Y84DcCKWXDmSDfn13bzFZY crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script><meta property="og:url" content="http://localhost:1313/posts/boj_19640/"><meta property="og:site_name" content="CS Playground"><meta property="og:title" content="BOJ 19640 - 화장실의 규칙"><meta property="og:description" content="시뮬레이션, 우선순위 큐"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-11-03T20:43:25+09:00"><meta property="article:modified_time" content="2025-11-03T20:43:25+09:00"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="BOJ 19640 - 화장실의 규칙"><meta name=twitter:description content="시뮬레이션, 우선순위 큐"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"BOJ 19640 - 화장실의 규칙","item":"http://localhost:1313/posts/boj_19640/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"BOJ 19640 - 화장실의 규칙","name":"BOJ 19640 - 화장실의 규칙","description":"시뮬레이션, 우선순위 큐","keywords":[],"articleBody":"튜터로 활동하고 있는 교내 알고리즘 튜터링 ‘알튜비튜’의 우선순위 큐 챕터 과제 문제이다.\n코드리뷰를 위해 문제를 풀어보았다.\n문제 회사의 화장실을 사용하려고 한다. 줄을 선 순서대로 사용할 수 있다.\n원래는 줄이 한 개지만, M개로 나뉘게 되었다.\n줄을 M개로 나누면서, 사람들은 1번째부터 M번째 줄에 원래 줄 순서대로 한 명씩 들어간다. 예를 들어, M이 4라면 다음과 같다.\n순서 들어가는 줄 1 1 2 2 3 3 4 1 5 2 … … 줄이 여러 개가 되었으니, 화장실을 사용하는 규칙도 변경이 있다.\nM개의 줄에서 맨 앞에 있는 사람 (여기서는 선두라고 부른다.)들을 서로 비교하여 규칙에 따라 사용할 수 있도록 한다.\n근무 일수(D)가 가장 높은 사람 D가 가장 높은 사람이 여러 명이라면, 화장실이 급한 정도(H)가 높은 사람 D와 H가 같고, 모두 가장 높은 사람이 여러 명이라면, 줄의 번호가 가장 낮은 사람 데카는 N명의 줄에 서 있고, 앞에는 K명의 사람이 있다.\n이 때, 데카가 화장실을 사용하기 위해선 몇 명이 화장실을 사용해야 할까?\n문제 분해 이 문제에서 해야 하는 작업을 정리해보자.\n기존 줄 1개를 M개의 줄로 분할. M개의 줄의 선두 중 주어진 조건에 따라 한 명의 선두를 선택. 근무 일수 D가 높은 사람 화장실이 급한 정도 H가 높은 사람 줄의 번호가 낮은 사람 아이디어 도출 과정을 그대로 시뮬레이션 하기 위해 queue를 사용하는 것이 가장 적절하다. (queue의 작동은 줄 서기와 유사하고, vector나 배열은 가장 앞 원소를 제거하는 기능이 없으므로) 데카의 위치를 기억하고, queue m개를 만들어 사원들을 집어넣은 후, 과정을 시뮬레이션하다 데카가 나오면 멈추고 해당 횟수를 리턴하면 된다. 이 때, 선두의 사원들 비교에 어떤 방법이 효율적일까? 배열에 넣고 소트 (nlogn) pq에 넣고 가장 앞 원소 꺼내기 (logn) 시간 복잡도가 2가 더 낮고, 또한 원소의 삽입이 잦으므로 매번 모든 원소를 정렬하는 것은 비효율적이다. 따라서 우선순위 큐를 통해 선두들의 순서를 관리해야겠다고 생각할 수 있다. 수도코드 queue v[m] // 1. queue에 정보 입력 for (int i = 0; i \u003c n; i++) { line_num = i % m; // Person 구조체는 (줄 번호, 줄에서의 순서, d, h로 이루어져 있다.) v[line_num] = {line_num, i / m, d, h} } // 2. pq 초기화 v에서 첫 원소만 빼서 pq에 push. // 3. 시뮬레이션 cnt = 0 // 데카 앞 사람 수 while (true) { // i. pq의 front를 뽑고, deka와 같다면 종료. 아니라면 계속 next = pq.front(); pop(); if pq == deka -\u003e break; // ii. next랑 같은 줄에서 다음 사람을 뽑음. 그리고 pq에 삽입. line_num = next.line_num; if (!v[line_num].empty()) pq.push(v[line_num].front()); pop(); deka++; } 고민한 것들 이렇게만 봐서는 정말 간단한 시뮬레이션 + 자료구조 문제인데… 고민과 시행착오가 좀 있었다.\n어떤 자료구조를 사용해야 할까? 줄을 세우는 문제라고 한다면, 당연히 queue를 자연스래 먼저 떠올리게 된다. 그래서 나도 자연스럽게 queue를 사용하려고 했지만, 걸리는 부분은 queue의 개수, 즉 줄의 개수인 M의 범위가 10e5까지였다는 점이었다.\n이거 너무 큰 거 아닌가?하긴 했는데 메모리 제한이 1024MB로 넉넉해서 일단 그냥 질러봤다. 그리고 메모리 문제는 다행히 발생하지 않았다. (72416KB 사용)\n참고로, 그냥 배열써도 문제는 없다. 큐를 사용한 건 모든 줄에서 앞 사람을 꺼내야 되기 때문에, 배열 쓰면 인덱스를 배열마다 저장해야 하는데 이게 실수하기 딱 좋다. 벡터도 pop_back을 쓸 생각이면 뒤집어서 배열을 채워야 하는데 이 때 배열 크기를 먼저 지정해줘야 하니까 계산을 해야 하고, 그게 아니라면 배열과 같다. 즉 실수하기 싫고 큐로 구현하는 게 편해서…ㅎㅎ\n그리고 시간 초과 처음 제출한 코드의 시뮬레이션 로직을 보자.\nint cnt = 0; while (true) { priority_queue\u003cPerson, vector\u003cPerson\u003e, Compare\u003e pq; // 1. 선두 꺼내기 for (auto \u0026q : v) { if (q.empty()) continue; pq.push(q.front()); } // 2. 뽑힌 선두 중 가장 높은 우선순위인 사람 꺼내기 Person next = pq.top(); pq.pop(); // 3. 데카면 종료, 아니면 계속 if (make_pair(next.line, next.order) == deka) break; for (auto \u0026q : v) { if (!q.empty() \u0026\u0026 q.front().line == next.line \u0026\u0026 q.front()order == next.order) { q.pop(); break; } } cnt++; } 무엇이 문제일까?\n바로 pq에 매 번 m개의 원소를 넣고 있다는 점이다.\n1개의 원소를 pq에 삽입하면 시간 복잡도가 O(logn), 이걸 m번씩 하는데 또 전체 루프가 최대 n번만큼 돌 수 있으므로 대략 **O(n^2logn)**라는… 어마무시한 시간이 걸린다.\n사실, pq에 매 번 새롭게 원소를 넣을 필요가 없다. 이전에 들어간 원소들은 남겨두고, 필요한 원소만 그때마다 넣어주는 방식이 더 효율적이다.\npriority_queue\u003cPerson, vector\u003cPerson\u003e, Compare\u003e pq; for (int i = 0; i \u003c n; i++) { line = i % m; order = i / m; cin \u003e\u003e d \u003e\u003e h; Person p = {line, order, d, h}; pq.push(p); } 하지만 답답했던 나는 그냥 모든 원소를 처음부터 pq에 때려 넣는다는 로직을 고안하였고, 결과적으로는 틀렸다ㅎㅎ\n틀린 이유는, 선두인 사람들만 주어진 규칙에 따라 비교해야 하는데, 이러면 고려할 필요가 없는 아직 선두가 아닌 사람들까지 비교하게 되기 때문이다. 따라서 순서가 꼬인다. 먼저 튀어나오면 안 되는 사람이 먼저 튀어나올 수 있다.\nwhile (true) { // 1. pq 초기화 for (auto \u0026q: v) { if (!q.empty()) { pq.push(q.front()); q.pop(); } } // 2. 뽑힌 선두 중 가장 높은 우선순위인 사람 꺼내기 Person next = pq.top(); pq.pop(); // 3. 데카면 종료, 아니면 계속 if (make_pair(next.line, next.order) == deka) break; cnt++; } 앞서 pq에 매번 원소를 새롭게 넣는 문제를 개선하기 위해 다음과 같이 수정했다.\n매 반복마다 v의 모든 q에서 원소를 하나씩 꺼내 pq에 넣어주는 방식이다.\n이 또한 아직 선두가 아닌 원소를 먼저 pq에 넣어버려 순서가 꼬여버린다는 문제가 있다. 반드시 선두인 원소끼리만 비교해주어야 한다.\n정답 따라서 다음과 같이 pq에서 원소가 빠져나가면, 해당 원소가 위치했던 줄에서 새로운 원소를 꺼내 pq에 삽입하면서, 각 줄의 선두만 pq에 포함될 수 있도록 수정하였다.\n// 1. pq 초기화 for (auto \u0026q: v) { if (!q.empty()) { pq.push(q.front()); q.pop(); } } while (true) { // 2. 뽑힌 선두 중 가장 높은 우선순위인 사람 꺼내기 Person next = pq.top(); pq.pop(); // 3. 데카면 종료, 아니면 계속 if (make_pair(next.line, next.order) == deka) break; // (4). 방금 사람 빼온 줄에서 새로운 사람 추가 if (!v[next.line].empty()) { pq.push(v[next.line].front()); v[next.line].pop(); } cnt++; } cout \u003c cnt; 후기 메모리는 생각보다 쉽게 초과되지 않는다. 그렇다고 해서 시간 초과 기준이 널널한 것은 또 아니다. 시뮬레이션 문제는 직접 시뮬레이션을 열심히 돌려보자. 그래야 작동 원리를 더욱 잘 이해할 수 있다. ","wordCount":"929","inLanguage":"en","image":"http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E","datePublished":"2025-11-03T20:43:25+09:00","dateModified":"2025-11-03T20:43:25+09:00","author":{"@type":"Person","name":"Me"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/boj_19640/"},"publisher":{"@type":"Organization","name":"CS Playground","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicons/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Home (Alt + H)"><img src=http://localhost:1313/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=archives><span>archives</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">BOJ 19640 - 화장실의 규칙</h1><div class=post-meta><span title='2025-11-03 20:43:25 +0900 KST'>November 3, 2025</span>&nbsp;·&nbsp;<span>5 min</span>&nbsp;·&nbsp;<span>Me</span>&nbsp;|&nbsp;<span>
<a href=https://github.com/chae-jpg/chae-jpg.github.io/content/posts/BOJ_19640.md rel="noopener noreferrer edit" target=_blank>Suggest Changes</a></span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#문제>문제</a></li><li><a href=#문제-분해>문제 분해</a></li><li><a href=#아이디어-도출>아이디어 도출</a></li><li><a href=#수도코드>수도코드</a></li><li><a href=#고민한-것들>고민한 것들</a><ul><li><a href=#어떤-자료구조를-사용해야-할까>어떤 자료구조를 사용해야 할까?</a></li><li><a href=#그리고-시간-초과>그리고 시간 초과</a></li></ul></li><li><a href=#정답>정답</a></li><li><a href=#후기>후기</a></li></ul></nav></div></details></div><div class=post-content><p>튜터로 활동하고 있는 교내 알고리즘 튜터링 &lsquo;알튜비튜&rsquo;의 우선순위 큐 챕터 과제 문제이다.<br>코드리뷰를 위해 문제를 풀어보았다.</p><h2 id=문제>문제<a hidden class=anchor aria-hidden=true href=#문제>#</a></h2><p>회사의 화장실을 사용하려고 한다. 줄을 선 순서대로 사용할 수 있다.<br>원래는 줄이 한 개지만, <strong>M개로 나뉘게 되었다.</strong><br>줄을 M개로 나누면서, 사람들은 1번째부터 M번째 줄에 원래 줄 순서대로 한 명씩 들어간다. 예를 들어, M이 4라면 다음과 같다.</p><table><thead><tr><th>순서</th><th>들어가는 줄</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr><tr><td>2</td><td>2</td></tr><tr><td>3</td><td>3</td></tr><tr><td>4</td><td><strong>1</strong></td></tr><tr><td>5</td><td><strong>2</strong></td></tr><tr><td>&mldr;</td><td>&mldr;</td></tr></tbody></table><p>줄이 여러 개가 되었으니, 화장실을 사용하는 규칙도 변경이 있다.<br>M개의 줄에서 맨 앞에 있는 사람 (여기서는 선두라고 부른다.)들을 서로 비교하여 규칙에 따라 사용할 수 있도록 한다.</p><ol><li>근무 일수(D)가 가장 높은 사람</li><li>D가 가장 높은 사람이 여러 명이라면, 화장실이 급한 정도(H)가 높은 사람</li><li>D와 H가 같고, 모두 가장 높은 사람이 여러 명이라면, 줄의 번호가 가장 낮은 사람</li></ol><p>데카는 N명의 줄에 서 있고, 앞에는 K명의 사람이 있다.<br><strong>이 때, 데카가 화장실을 사용하기 위해선 몇 명이 화장실을 사용해야 할까?</strong></p><h2 id=문제-분해>문제 분해<a hidden class=anchor aria-hidden=true href=#문제-분해>#</a></h2><p>이 문제에서 해야 하는 작업을 정리해보자.</p><ol><li>기존 줄 1개를 M개의 줄로 분할.</li><li>M개의 줄의 선두 중 주어진 조건에 따라 한 명의 선두를 선택.<ol><li>근무 일수 D가 높은 사람</li><li>화장실이 급한 정도 H가 높은 사람</li><li>줄의 번호가 낮은 사람</li></ol></li></ol><h2 id=아이디어-도출>아이디어 도출<a hidden class=anchor aria-hidden=true href=#아이디어-도출>#</a></h2><ul><li>과정을 그대로 시뮬레이션 하기 위해 <strong>queue</strong>를 사용하는 것이 가장 적절하다. (queue의 작동은 줄 서기와 유사하고, vector나 배열은 가장 앞 원소를 제거하는 기능이 없으므로)</li><li>데카의 위치를 기억하고, queue m개를 만들어 사원들을 집어넣은 후, 과정을 시뮬레이션하다 데카가 나오면 멈추고 해당 횟수를 리턴하면 된다.</li><li>이 때, 선두의 사원들 비교에 어떤 방법이 효율적일까?<ul><li><ol><li>배열에 넣고 소트 (nlogn)</li></ol></li><li><ol start=2><li>pq에 넣고 가장 앞 원소 꺼내기 (logn)</li></ol></li><li>시간 복잡도가 2가 더 낮고, 또한 원소의 삽입이 잦으므로 매번 모든 원소를 정렬하는 것은 비효율적이다. 따라서 <strong>우선순위 큐</strong>를 통해 선두들의 순서를 관리해야겠다고 생각할 수 있다.</li></ul></li></ul><h2 id=수도코드>수도코드<a hidden class=anchor aria-hidden=true href=#수도코드>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>queue&lt;Person&gt; v[m]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 1. queue에 정보 입력
</span></span><span class=line><span class=cl>for (int i = 0; i &lt; n; i++) {
</span></span><span class=line><span class=cl>    line_num = i % m;
</span></span><span class=line><span class=cl>    // Person 구조체는 (줄 번호, 줄에서의 순서, d, h로 이루어져 있다.)
</span></span><span class=line><span class=cl>    v[line_num] = {line_num, i / m, d, h}
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 2. pq 초기화
</span></span><span class=line><span class=cl>v에서 첫 원소만 빼서 pq에 push.
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>// 3. 시뮬레이션
</span></span><span class=line><span class=cl>cnt = 0 // 데카 앞 사람 수
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>while (true) {
</span></span><span class=line><span class=cl>    // i. pq의 front를 뽑고, deka와 같다면 종료. 아니라면 계속 
</span></span><span class=line><span class=cl>    next = pq.front(); pop();
</span></span><span class=line><span class=cl>    if pq == deka -&gt; break;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    // ii. next랑 같은 줄에서 다음 사람을 뽑음. 그리고 pq에 삽입.
</span></span><span class=line><span class=cl>    line_num = next.line_num;
</span></span><span class=line><span class=cl>    if (!v[line_num].empty()) pq.push(v[line_num].front()); pop();
</span></span><span class=line><span class=cl>    deka++;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></div><h2 id=고민한-것들>고민한 것들<a hidden class=anchor aria-hidden=true href=#고민한-것들>#</a></h2><p>이렇게만 봐서는 정말 간단한 시뮬레이션 + 자료구조 문제인데&mldr; 고민과 시행착오가 좀 있었다.</p><h3 id=어떤-자료구조를-사용해야-할까>어떤 자료구조를 사용해야 할까?<a hidden class=anchor aria-hidden=true href=#어떤-자료구조를-사용해야-할까>#</a></h3><p>줄을 세우는 문제라고 한다면, 당연히 queue를 자연스래 먼저 떠올리게 된다. 그래서 나도 자연스럽게 queue를 사용하려고 했지만, 걸리는 부분은 queue의 개수, 즉 줄의 개수인 M의 범위가 10e5까지였다는 점이었다.</p><p>이거 너무 큰 거 아닌가?하긴 했는데 메모리 제한이 1024MB로 넉넉해서 일단 그냥 질러봤다. 그리고 메모리 문제는 다행히 발생하지 않았다. (72416KB 사용)</p><p>참고로, 그냥 배열써도 문제는 없다. 큐를 사용한 건 모든 줄에서 앞 사람을 꺼내야 되기 때문에, 배열 쓰면 인덱스를 배열마다 저장해야 하는데 이게 실수하기 딱 좋다. 벡터도 <code>pop_back</code>을 쓸 생각이면 뒤집어서 배열을 채워야 하는데 이 때 배열 크기를 먼저 지정해줘야 하니까 계산을 해야 하고, 그게 아니라면 배열과 같다. 즉 실수하기 싫고 큐로 구현하는 게 편해서&mldr;ㅎㅎ</p><h3 id=그리고-시간-초과>그리고 시간 초과<a hidden class=anchor aria-hidden=true href=#그리고-시간-초과>#</a></h3><p>처음 제출한 코드의 시뮬레이션 로직을 보자.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>cnt</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>priority_queue</span><span class=o>&lt;</span><span class=n>Person</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>Person</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>Compare</span><span class=o>&gt;</span> <span class=n>pq</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. 선두 꺼내기
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=nl>q</span> <span class=p>:</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>q</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=k>continue</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>pq</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>q</span><span class=p>.</span><span class=n>front</span><span class=p>());</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 뽑힌 선두 중 가장 높은 우선순위인 사람 꺼내기
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Person</span> <span class=n>next</span> <span class=o>=</span> <span class=n>pq</span><span class=p>.</span><span class=n>top</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>pq</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 데카면 종료, 아니면 계속
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>make_pair</span><span class=p>(</span><span class=n>next</span><span class=p>.</span><span class=n>line</span><span class=p>,</span> <span class=n>next</span><span class=p>.</span><span class=n>order</span><span class=p>)</span> <span class=o>==</span> <span class=n>deka</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=nl>q</span> <span class=p>:</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>q</span><span class=p>.</span><span class=n>empty</span><span class=p>()</span> <span class=o>&amp;&amp;</span> <span class=n>q</span><span class=p>.</span><span class=n>front</span><span class=p>().</span><span class=n>line</span> <span class=o>==</span> <span class=n>next</span><span class=p>.</span><span class=n>line</span> <span class=o>&amp;&amp;</span> <span class=n>q</span><span class=p>.</span><span class=n>front</span><span class=p>()</span><span class=n>order</span> <span class=o>==</span> <span class=n>next</span><span class=p>.</span><span class=n>order</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>q</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>cnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>무엇이 문제일까?<br>바로 pq에 매 번 m개의 원소를 넣고 있다는 점이다.<br>1개의 원소를 pq에 삽입하면 시간 복잡도가 O(logn), 이걸 m번씩 하는데 또 전체 루프가 최대 n번만큼 돌 수 있으므로 대략 **O(n^2logn)**라는&mldr; 어마무시한 시간이 걸린다.</p><p>사실, pq에 매 번 새롭게 원소를 넣을 필요가 없다. 이전에 들어간 원소들은 남겨두고, 필요한 원소만 그때마다 넣어주는 방식이 더 효율적이다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>priority_queue</span><span class=o>&lt;</span><span class=n>Person</span><span class=p>,</span> <span class=n>vector</span><span class=o>&lt;</span><span class=n>Person</span><span class=o>&gt;</span><span class=p>,</span> <span class=n>Compare</span><span class=o>&gt;</span> <span class=n>pq</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>n</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>line</span> <span class=o>=</span> <span class=n>i</span> <span class=o>%</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>order</span> <span class=o>=</span> <span class=n>i</span> <span class=o>/</span> <span class=n>m</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cin</span> <span class=o>&gt;&gt;</span> <span class=n>d</span> <span class=o>&gt;&gt;</span> <span class=n>h</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>Person</span> <span class=n>p</span> <span class=o>=</span> <span class=p>{</span><span class=n>line</span><span class=p>,</span> <span class=n>order</span><span class=p>,</span> <span class=n>d</span><span class=p>,</span> <span class=n>h</span><span class=p>};</span>
</span></span><span class=line><span class=cl>    <span class=n>pq</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span></code></pre></div><p>하지만 답답했던 나는 그냥 모든 원소를 처음부터 pq에 때려 넣는다는 로직을 고안하였고, 결과적으로는 틀렸다ㅎㅎ</p><p>틀린 이유는, 선두인 사람들만 주어진 규칙에 따라 비교해야 하는데, 이러면 고려할 필요가 없는 <strong>아직 선두가 아닌 사람들</strong>까지 비교하게 되기 때문이다. 따라서 순서가 꼬인다. 먼저 튀어나오면 안 되는 사람이 먼저 튀어나올 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 1. pq 초기화
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=nl>q</span><span class=p>:</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>q</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>pq</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>q</span><span class=p>.</span><span class=n>front</span><span class=p>());</span>
</span></span><span class=line><span class=cl>            <span class=n>q</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 뽑힌 선두 중 가장 높은 우선순위인 사람 꺼내기
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Person</span> <span class=n>next</span> <span class=o>=</span> <span class=n>pq</span><span class=p>.</span><span class=n>top</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>pq</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 데카면 종료, 아니면 계속
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>make_pair</span><span class=p>(</span><span class=n>next</span><span class=p>.</span><span class=n>line</span><span class=p>,</span> <span class=n>next</span><span class=p>.</span><span class=n>order</span><span class=p>)</span> <span class=o>==</span> <span class=n>deka</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>앞서 pq에 매번 원소를 새롭게 넣는 문제를 개선하기 위해 다음과 같이 수정했다.<br>매 반복마다 v의 모든 q에서 원소를 하나씩 꺼내 pq에 넣어주는 방식이다.<br>이 또한 아직 선두가 아닌 원소를 먼저 pq에 넣어버려 순서가 꼬여버린다는 문제가 있다. 반드시 <strong>선두인 원소끼리만 비교</strong>해주어야 한다.</p><hr><h2 id=정답>정답<a hidden class=anchor aria-hidden=true href=#정답>#</a></h2><p>따라서 다음과 같이 pq에서 원소가 빠져나가면, 해당 원소가 위치했던 줄에서 새로운 원소를 꺼내 pq에 삽입하면서, <strong>각 줄의 선두만 pq에 포함될 수 있도록</strong> 수정하였다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// 1. pq 초기화
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=k>auto</span> <span class=o>&amp;</span><span class=nl>q</span><span class=p>:</span> <span class=n>v</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>q</span><span class=p>.</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pq</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>q</span><span class=p>.</span><span class=n>front</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=n>q</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>while</span> <span class=p>(</span><span class=nb>true</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 2. 뽑힌 선두 중 가장 높은 우선순위인 사람 꺼내기
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>Person</span> <span class=n>next</span> <span class=o>=</span> <span class=n>pq</span><span class=p>.</span><span class=n>top</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>pq</span><span class=p>.</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 3. 데카면 종료, 아니면 계속
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=n>make_pair</span><span class=p>(</span><span class=n>next</span><span class=p>.</span><span class=n>line</span><span class=p>,</span> <span class=n>next</span><span class=p>.</span><span class=n>order</span><span class=p>)</span> <span class=o>==</span> <span class=n>deka</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// (4). 방금 사람 빼온 줄에서 새로운 사람 추가
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>v</span><span class=p>[</span><span class=n>next</span><span class=p>.</span><span class=n>line</span><span class=p>].</span><span class=n>empty</span><span class=p>())</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>pq</span><span class=p>.</span><span class=n>push</span><span class=p>(</span><span class=n>v</span><span class=p>[</span><span class=n>next</span><span class=p>.</span><span class=n>line</span><span class=p>].</span><span class=n>front</span><span class=p>());</span>
</span></span><span class=line><span class=cl>        <span class=n>v</span><span class=p>[</span><span class=n>next</span><span class=p>.</span><span class=n>line</span><span class=p>].</span><span class=n>pop</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>cnt</span><span class=o>++</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>cout</span> <span class=o>&lt;</span> <span class=n>cnt</span><span class=p>;</span>
</span></span></code></pre></div><h2 id=후기>후기<a hidden class=anchor aria-hidden=true href=#후기>#</a></h2><ol><li>메모리는 생각보다 쉽게 초과되지 않는다.</li><li>그렇다고 해서 시간 초과 기준이 널널한 것은 또 아니다.</li><li>시뮬레이션 문제는 직접 시뮬레이션을 열심히 돌려보자. 그래야 작동 원리를 더욱 잘 이해할 수 있다.</li></ol></div><footer class=post-footer><ul class=post-tags></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/deepfm/><span class=title>« Prev</span><br><span>DeepFM: A Factorization-Machine based Neural Network for CTR Prediction</span>
</a><a class=next href=http://localhost:1313/posts/network_2/><span class=title>Next »</span><br><span>Computer Network - Chap. 2</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share BOJ 19640 - 화장실의 규칙 on x" href="https://x.com/intent/tweet/?text=BOJ%2019640%20-%20%ed%99%94%ec%9e%a5%ec%8b%a4%ec%9d%98%20%ea%b7%9c%ec%b9%99&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fboj_19640%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share BOJ 19640 - 화장실의 규칙 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fboj_19640%2f&amp;title=BOJ%2019640%20-%20%ed%99%94%ec%9e%a5%ec%8b%a4%ec%9d%98%20%ea%b7%9c%ec%b9%99&amp;summary=BOJ%2019640%20-%20%ed%99%94%ec%9e%a5%ec%8b%a4%ec%9d%98%20%ea%b7%9c%ec%b9%99&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fboj_19640%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share BOJ 19640 - 화장실의 규칙 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fboj_19640%2f&title=BOJ%2019640%20-%20%ed%99%94%ec%9e%a5%ec%8b%a4%ec%9d%98%20%ea%b7%9c%ec%b9%99"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share BOJ 19640 - 화장실의 규칙 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fboj_19640%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share BOJ 19640 - 화장실의 규칙 on whatsapp" href="https://api.whatsapp.com/send?text=BOJ%2019640%20-%20%ed%99%94%ec%9e%a5%ec%8b%a4%ec%9d%98%20%ea%b7%9c%ec%b9%99%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fboj_19640%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share BOJ 19640 - 화장실의 규칙 on telegram" href="https://telegram.me/share/url?text=BOJ%2019640%20-%20%ed%99%94%ec%9e%a5%ec%8b%a4%ec%9d%98%20%ea%b7%9c%ec%b9%99&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fboj_19640%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share BOJ 19640 - 화장실의 규칙 on ycombinator" href="https://news.ycombinator.com/submitlink?t=BOJ%2019640%20-%20%ed%99%94%ec%9e%a5%ec%8b%a4%ec%9d%98%20%ea%b7%9c%ec%b9%99&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fboj_19640%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=http://localhost:1313/>CS Playground</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>